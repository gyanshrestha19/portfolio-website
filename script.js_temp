// ===================== DUST PARTICLES — DENSE, VARIED =====================
(function createParticles() {
  const container = document.getElementById('particles');
  if (!container) return;

  // Regular dust motes
  for (let i = 0; i < 55; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    const size = Math.random() * 3.2 + 0.3;
    const isGolden = Math.random() > 0.45;
    p.style.cssText = `
      left: ${Math.random() * 100}%;
      width: ${size}px; height: ${size}px;
      opacity: ${Math.random() * 0.4 + 0.06};
      animation-duration: ${Math.random() * 28 + 16}s;
      animation-delay: ${Math.random() * 28}s;
      --drift-x: ${(Math.random() - 0.5) * 220}px;
      background: rgba(${isGolden ? '255,210,130' : '190,165,110'},${Math.random() * 0.5 + 0.1});
      filter: blur(${Math.random() > 0.7 ? '0.8px' : '0px'});
    `;
    container.appendChild(p);
  }

  // Larger floating debris
  for (let i = 0; i < 8; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    const size = Math.random() * 5 + 3;
    p.style.cssText = `
      left: ${Math.random() * 100}%;
      width: ${size}px; height: ${size}px;
      opacity: ${Math.random() * 0.18 + 0.04};
      animation-duration: ${Math.random() * 45 + 35}s;
      animation-delay: ${Math.random() * 35}s;
      --drift-x: ${(Math.random() - 0.5) * 100}px;
      background: rgba(200,180,120,0.25);
      filter: blur(${Math.random() * 1.5 + 0.5}px);
      border-radius: ${Math.random() > 0.5 ? '2px' : '50%'};
    `;
    container.appendChild(p);
  }
})();

// ===================== SCROLL REVEAL =====================
(function initReveal() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) entry.target.classList.add('visible');
    });
  }, { threshold: 0.06, rootMargin: '0px 0px -30px 0px' });

  document.querySelectorAll('.reveal').forEach((el, i) => {
    el.style.transitionDelay = (i % 7) * 0.09 + 's';
    observer.observe(el);
  });
})();

// ===================== DEPTH LAYER ASSIGNMENT =====================
(function assignDepthLayers() {
  document.querySelectorAll('.project-file .polaroid').forEach(p => p.classList.add('depth-far'));
  document.querySelectorAll('.sticky').forEach((s, i) => {
    if (i % 3 === 2) s.classList.add('depth-mid');
  });
})();

// ===================== PARALLAX + DEPTH BLUR ON SCROLL =====================
(function initParallax() {
  const panels = Array.from(document.querySelectorAll('.cork-panel')).map(panel => ({
    el: panel,
    top: panel.offsetTop,
    height: panel.offsetHeight
  }));

  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        const y = window.scrollY;
        const vh = window.innerHeight;

        panels.forEach((p, i) => {
          const offset = (i % 2 === 0 ? 1 : -1) * y * 0.01;
          // Calculate distance from center without layout thrashing
          const panelCenter = p.top + p.height / 2;
          const distFromCenter = Math.abs((panelCenter - y) - vh / 2);
          const maxDist = vh;
          const dimAmt = 1 - Math.min((distFromCenter / maxDist) * 0.18, 0.18);
          // Slight perspective tilt based on scroll position
          const tiltX = offset * 0.06;
          p.el.style.transform = `perspective(1400px) rotateX(${tiltX}deg) translateZ(0)`;
          p.el.style.filter = `brightness(${dimAmt.toFixed(3)})`;
        });
        ticking = false;
      });
      ticking = true;
    }
  }, { passive: true });
})();


// ===================== CAMERA DRIFT — ORGANIC, HANDHELD FEEL =====================
(function initCameraDrift() {
  const wrap = document.getElementById('camera-wrap');
  if (!wrap) return;

  let driftX = 0, driftY = 0, targetX = 0, targetY = 0, t = 0;
  let mouseX = 0, mouseY = 0, mouseActive = false;
  let breathPhase = 0;

  // Perlin-like noise using overlapping sines
  function noiseX(t) {
    return (
      Math.sin(t * 0.00021) * 4.2 +
      Math.sin(t * 0.00038) * 2.4 +
      Math.sin(t * 0.00071) * 1.4 +
      Math.sin(t * 0.00142) * 0.6
    );
  }
  function noiseY(t) {
    return (
      Math.sin(t * 0.00017 + 1.8) * 3.2 +
      Math.sin(t * 0.00034 + 0.7) * 1.9 +
      Math.sin(t * 0.00063 + 2.4) * 1.1 +
      Math.sin(t * 0.00118 + 1.1) * 0.5
    );
  }
  // Subtle zoom breathing
  function breathe(t) {
    return 1 + Math.sin(t * 0.00011) * 0.0018 + Math.sin(t * 0.00023) * 0.001;
  }

  document.addEventListener('mousemove', (e) => {
    mouseX = ((e.clientX / window.innerWidth) - 0.5) * 5.5;
    mouseY = ((e.clientY / window.innerHeight) - 0.5) * 3.5;
    mouseActive = true;
  });

  let then = performance.now();
  function tick(now) {
    const dt = Math.min(now - then, 50); then = now; t += dt;

    const autoX = noiseX(t);
    const autoY = noiseY(t);
    targetX = autoX + (mouseActive ? mouseX * 0.38 : 0);
    targetY = autoY + (mouseActive ? mouseY * 0.28 : 0);

    const lerp = 0.016;
    driftX += (targetX - driftX) * lerp;
    driftY += (targetY - driftY) * lerp;

    const rotZ = driftX * 0.016;
    const scaleVal = breathe(t) + Math.abs(driftX) * 0.0003;

    wrap.style.transform = `translate(${driftX.toFixed(3)}px, ${driftY.toFixed(3)}px) rotate(${rotZ.toFixed(4)}deg) scale(${scaleVal.toFixed(5)})`;
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();



// ===================== HOVER TILT ON PAPERS =====================
document.querySelectorAll('.paper, .polaroid').forEach(el => {
  el.addEventListener('mousemove', (e) => {
    const rect = el.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width - 0.5;
    const y = (e.clientY - rect.top) / rect.height - 0.5;
    el.style.transition = 'transform 0.12s ease, filter 0.25s ease, box-shadow 0.25s ease';
    el.style.transform = `scale(1.025) rotateY(${x * 7}deg) rotateX(${-y * 5}deg)`;
    el.style.filter = 'brightness(1.07)';
    // Dynamic cast shadow based on tilt angle
    const shadowX = x * 15; const shadowY = y * 10;
    el.style.boxShadow = `${shadowX}px ${shadowY + 15}px 40px rgba(0,0,0,0.85), ${shadowX * 0.5}px ${shadowY * 0.5 + 25}px 60px rgba(0,0,0,0.55)`;
  });
  el.addEventListener('mouseleave', () => {
    el.style.transition = 'transform 0.45s ease, filter 0.5s ease, box-shadow 0.45s ease';
    el.style.transform = '';
    el.style.filter = '';
    el.style.boxShadow = '';
  });
});

// ===================== REALISTIC PIN SVG INJECTION =====================
(function renderPins() {
  const palettes = {
    'pin-red': { h1: '#FF9090', h2: '#CC1818', h3: '#820000', rim: '#520000', glow: 'rgba(200,24,24,0.5)', metal: '#B84040' },
    'pin-gold': { h1: '#FFF888', h2: '#D0A828', h3: '#806000', rim: '#402E00', glow: 'rgba(200,165,40,0.4)', metal: '#B89020' },
    'pin-white': { h1: '#FFFFFF', h2: '#D8D8D8', h3: '#989898', rim: '#585858', glow: 'rgba(240,240,240,0.3)', metal: '#B0B0B0' },
    'pin-blue': { h1: '#A0C4FF', h2: '#1A4EC0', h3: '#081848', rim: '#030C30', glow: 'rgba(26,78,192,0.5)', metal: '#1030A0' },
  };

  document.querySelectorAll('.pin').forEach((pin, index) => {
    let palette = palettes['pin-red'];
    for (const cls of Object.keys(palettes)) {
      if (pin.classList.contains(cls)) { palette = palettes[cls]; break; }
    }

    // Hand-placed randomness — slight random rotation/skew
    const tilt = (Math.random() - 0.5) * 16;
    const existing = pin.style.transform || '';
    pin.style.transform = existing ? `${existing} rotate(${tilt}deg)` : `rotate(${tilt}deg)`;

    const uid = `ph-${index}`;
    const shUid = `ps-${index}`;
    const blurId = `pb-${index}`;
    const rimId = `pr-${index}`;
    const scratchId = `sc-${index}`;

    pin.innerHTML = `
    <svg viewBox="-12 -6 48 58" xmlns="http://www.w3.org/2000/svg" overflow="visible" style="width:32px;height:50px;">
      <defs>
        <filter id="${blurId}" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="1.6"/>
        </filter>
        <filter id="${blurId}2" x="-20%" y="-20%" width="140%" height="140%">
          <feGaussianBlur stdDeviation="0.4"/>
        </filter>
        <radialGradient id="${uid}" cx="32%" cy="26%" r="70%" fx="30%" fy="24%">
          <stop offset="0%"   stop-color="${palette.h1}"/>
          <stop offset="18%"  stop-color="${palette.h2}" stop-opacity="0.95"/>
          <stop offset="58%"  stop-color="${palette.h3}"/>
          <stop offset="88%"  stop-color="${palette.rim}"/>
          <stop offset="100%" stop-color="rgba(0,0,0,0.8)"/>
        </radialGradient>
        <radialGradient id="${rimId}" cx="50%" cy="50%" r="50%">
          <stop offset="58%" stop-color="transparent"/>
          <stop offset="85%" stop-color="rgba(0,0,0,0.35)"/>
          <stop offset="100%" stop-color="rgba(0,0,0,0.7)"/>
        </radialGradient>
        <linearGradient id="${shUid}" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%"   stop-color="#6A5E50"/>
          <stop offset="22%"  stop-color="#C8BCA8"/>
          <stop offset="50%"  stop-color="#B8AC98"/>
          <stop offset="78%"  stop-color="#C0B4A0"/>
          <stop offset="100%" stop-color="#605448"/>
        </linearGradient>
        <!-- Scratch texture on sphere -->
        <filter id="${scratchId}">
          <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" result="noise"/>
          <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.05 0" result="scratch"/>
          <feComposite in="SourceGraphic" in2="scratch" operator="over"/>
        </filter>
      </defs>

      <!-- 1. Cork indentation shadow — where pin enters board -->
      <ellipse cx="12" cy="47" rx="9" ry="3" fill="rgba(0,0,0,0.4)" filter="url(#${blurId})"/>
      <!-- 2. Shaft cast shadow — thin line on paper -->
      <path d="M 9.5 22 L 16 44 L 20 46 L 12.5 22 Z" fill="rgba(0,0,0,0.22)" filter="url(#${blurId})"/>

      <!-- 3. Metal shaft — tapered needle -->
      <path d="M 10.5 19 L 13.5 19 L 13.2 43 Q 12 46.5 10.8 43 Z" fill="url(#${shUid})"/>
      <!-- Shaft highlight — light catching metal taper -->
      <line x1="12.4" y1="20" x2="12.8" y2="42" stroke="rgba(255,255,255,0.28)" stroke-width="0.7" stroke-linecap="round"/>
      <!-- Shaft edge shadow -->
      <line x1="13.2" y1="20" x2="13.0" y2="42" stroke="rgba(0,0,0,0.25)" stroke-width="0.5"/>

      <!-- 4. Ambient glow sphere -->
      <circle cx="12" cy="11" r="13" fill="${palette.glow}" filter="url(#${blurId})"/>
      <!-- 5. Main sphere body -->
      <circle cx="12" cy="11" r="11" fill="url(#${uid})" filter="url(#${scratchId})"/>
      <!-- 6. Rim darkening -->
      <circle cx="12" cy="11" r="11" fill="url(#${rimId})"/>
      <!-- 7. Subsurface depth — slight inner shadow at equator -->
      <ellipse cx="12" cy="16" rx="9" ry="5" fill="rgba(0,0,0,0.12)" filter="url(#${blurId}2)"/>

      <!-- 8. Specular highlights — primary -->
      <ellipse cx="7.8" cy="6.8" rx="4.8" ry="3.5" fill="rgba(255,255,255,0.38)" transform="rotate(-30,7.8,6.8)"/>
      <!-- Secondary sharp glint -->
      <circle cx="6.5" cy="5.5" r="1.6" fill="rgba(255,255,255,0.72)"/>
      <!-- Tiny tertiary glint -->
      <circle cx="8.8" cy="4.2" r="0.6" fill="rgba(255,255,255,0.5)"/>
      <!-- Far-side soft reflection -->
      <ellipse cx="17" cy="16" rx="2" ry="1.2" fill="rgba(255,255,255,0.08)" transform="rotate(20,17,16)"/>

      <!-- 9. Underside shadow crescent -->
      <path d="M 2.5 17 Q 12 22 21.5 17" fill="none" stroke="${palette.rim}" stroke-width="2.2" opacity="0.5" stroke-linecap="round"/>

      <!-- 10. Collar ring — where head meets shaft -->
      <ellipse cx="12" cy="21" rx="3.8" ry="1.6" fill="${palette.h3}" opacity="0.88"/>
      <ellipse cx="12" cy="21" rx="3.8" ry="1.6" fill="none" stroke="rgba(0,0,0,0.3)" stroke-width="0.6"/>
      <!-- Collar highlight -->
      <ellipse cx="10.5" cy="20.4" rx="1.8" ry="0.6" fill="rgba(255,255,255,0.18)" transform="rotate(-15,10.5,20.4)"/>

      <!-- 11. Needle tip with worn point -->
      <path d="M 10.8 43 Q 12 47.5 13.2 43 Q 12 45 10.8 43 Z" fill="#7A7060"/>
      <path d="M 11.5 45 Q 12 47.5 12.5 45 Z" fill="rgba(0,0,0,0.4)"/>
    </svg>`;
  });
})();

// ===================== LIGHT BULB TOGGLE =====================
(function initBulbToggle() {
  const btn = document.getElementById('bulb-btn');
  const bulb = document.getElementById('bulb');
  const fixture = document.getElementById('light-fixture');
  const halo = document.getElementById('light-halo');
  const cone = document.getElementById('light-cone');
  if (!btn || !bulb) return;

  let isOn = true;
  let flickerTimer = null;

  function setIntensity(v, duration = 30) {
    bulb.style.transition = `opacity ${duration}ms`;
    bulb.style.opacity = v;
    if (halo) { halo.style.transition = `opacity ${duration * 2}ms`; halo.style.opacity = v * 0.92; }
    if (cone) { cone.style.transition = `opacity ${duration * 3}ms`; cone.style.opacity = v * 0.85; }
  }

  function scheduleFlicker() {
    if (!isOn) return;
    const delay = 2200 + Math.random() * 6000;
    flickerTimer = setTimeout(() => {
      if (!isOn) return;
      const roll = Math.random();

      if (roll > 0.86) {
        // Quick single dip
        setIntensity(0.4 + Math.random() * 0.25, 25);
        setTimeout(() => { if (isOn) setIntensity(1, 60); }, 40 + Math.random() * 60);
      }
      if (roll > 0.94) {
        // Double flicker
        setIntensity(0.55, 20);
        setTimeout(() => { if (isOn) setIntensity(0.9, 40); }, 80);
        setTimeout(() => { if (isOn) setIntensity(0.42, 20); }, 160);
        setTimeout(() => { if (isOn) setIntensity(1, 80); }, 230);
      }
      if (roll > 0.98) {
        // Long stutter — bad connection
        setIntensity(0.15, 15);
        setTimeout(() => { if (isOn) setIntensity(0.85, 30); }, 50);
        setTimeout(() => { if (isOn) setIntensity(0.2, 15); }, 105);
        setTimeout(() => { if (isOn) setIntensity(0.7, 30); }, 155);
        setTimeout(() => { if (isOn) setIntensity(0.35, 15); }, 210);
        setTimeout(() => { if (isOn) setIntensity(1, 120); }, 270);
      }

      scheduleFlicker();
    }, delay);
  }

  function turnOn() {
    isOn = true;
    bulb.classList.remove('bulb-off');
    bulb.classList.add('bulb-on');
    bulb.style.opacity = '0';

    // Warm-up sequence — tungsten taking time to heat
    setTimeout(() => setIntensity(0.15, 80), 40);
    setTimeout(() => setIntensity(0.55, 100), 120);
    setTimeout(() => {
      bulb.style.filter = 'brightness(1.6) saturate(0.7)';
      setIntensity(0.88, 60);
    }, 230);
    setTimeout(() => {
      bulb.style.filter = 'brightness(1.25)';
      setIntensity(1, 80);
    }, 320);
    setTimeout(() => {
      bulb.style.filter = 'brightness(1)';
    }, 500);

    if (halo) { halo.style.transition = 'opacity 0.6s ease'; halo.style.opacity = '1'; }
    if (cone) { cone.style.transition = 'opacity 0.8s ease'; cone.style.opacity = '1'; }
    fixture.classList.remove('lights-off');
    document.body.classList.remove('lights-off');

    setTimeout(scheduleFlicker, 3000);
  }

  function turnOff() {
    isOn = false;
    clearTimeout(flickerTimer);

    // Rapid off — maybe a slight afterglow
    setIntensity(0.7, 40);
    setTimeout(() => {
      bulb.classList.remove('bulb-on');
      bulb.classList.add('bulb-off');
      // Brief hot glow fades slowly (tungsten afterglow)
      bulb.style.transition = 'opacity 0.8s ease';
      bulb.style.filter = 'brightness(0.6) saturate(0.4)';
      bulb.style.opacity = '0.18';
      if (halo) { halo.style.transition = 'opacity 0.4s ease'; halo.style.opacity = '0.05'; }
      if (cone) { cone.style.transition = 'opacity 0.3s ease'; cone.style.opacity = '0'; }
    }, 65);
    setTimeout(() => {
      bulb.style.opacity = '0';
      bulb.style.filter = '';
      if (halo) halo.style.opacity = '0';
      fixture.classList.add('lights-off');
      document.body.classList.add('lights-off');
    }, 900);
  }

  btn.addEventListener('click', () => { isOn ? turnOff() : turnOn(); });
  // Initial flicker start after page load
  setTimeout(scheduleFlicker, 3500);
})();

// ===================== BINDER HOLES =====================
(function injectBinderHoles() {
  document.querySelectorAll('.binder-holes').forEach(el => {
    el.innerHTML = '';
    for (let i = 0; i < 3; i++) {
      const hole = document.createElement('div');
      hole.style.cssText = `
        width:13px; height:13px; border-radius:50%;
        border:1.5px solid rgba(0,0,0,0.2);
        box-shadow: inset 0 1px 4px rgba(0,0,0,0.3), inset 0 -1px 2px rgba(255,255,255,0.08), 0 1px 0 rgba(255,255,255,0.15);
        background: radial-gradient(circle at 40% 35%, rgba(255,255,255,0.06), rgba(0,0,0,0.12));
        margin-bottom: ${i < 2 ? '20px' : '0'};
      `;
      el.appendChild(hole);
    }
  });
})();

// ===================== SMOOTH SCROLL =====================
document.querySelectorAll('a[href^="#"]').forEach(a => {
  a.addEventListener('click', e => {
    e.preventDefault();
    document.querySelector(a.getAttribute('href'))?.scrollIntoView({ behavior: 'smooth' });
  });
});

// ===================== TYPING EFFECT ON CASE NUMBERS =====================
(function typeEffect() {
  document.querySelectorAll('.case-number').forEach(el => {
    const text = el.textContent;
    el.textContent = '';
    let i = 0;
    const observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) {
        // Typewriter with slight irregularity
        function typeNext() {
          if (i < text.length) {
            el.textContent += text[i++];
            const delay = 30 + Math.random() * 35; // uneven typing speed
            setTimeout(typeNext, delay);
          }
        }
        typeNext();
        observer.disconnect();
      }
    });
    observer.observe(el);
  });
})();

// ===================== PAPER MICRO-INTERACTION — CLICK RIPPLE =====================
document.querySelectorAll('.paper').forEach(el => {
  el.addEventListener('click', (e) => {
    const rect = el.getBoundingClientRect();
    const ripple = document.createElement('div');
    ripple.style.cssText = `
      position:absolute;
      width:8px; height:8px; border-radius:50%;
      left:${e.clientX - rect.left - 4}px;
      top:${e.clientY - rect.top - 4}px;
      background:rgba(178,34,34,0.2);
      pointer-events:none; z-index:999;
      animation: ripple-ink 0.5s ease-out forwards;
    `;
    el.style.position = 'relative';
    el.appendChild(ripple);
    setTimeout(() => ripple.remove(), 500);
  });
});

// Inject keyframes for ripple
const style = document.createElement('style');
style.textContent = `
@keyframes ripple-ink {
  from { transform: scale(0); opacity: 0.5; }
  to { transform: scale(8); opacity: 0; }
}
@keyframes draw-string { to { stroke-dashoffset: 0; } }
`;
document.head.appendChild(style);

// ===================== RANDOM PAPER MICRO-MOVEMENT — papers subtly settle =====================
(function subtlePaperSettle() {
  document.querySelectorAll('.paper:not(:hover), .sticky:not(:hover)').forEach((el, i) => {
    // Tiny random shift every few seconds — paper settling on cork
    const baseDelay = Math.random() * 8000;
    setInterval(() => {
      if (el.matches(':hover')) return;
      const dx = (Math.random() - 0.5) * 0.4;
      const dy = (Math.random() - 0.5) * 0.3;
      const currentTransform = el.style.transform || '';
      // Only add micro-shift if not being hovered
      el.style.transition = 'transform 2s ease';
    }, 8000 + baseDelay);
  });
})();

// ===================== LIGHT CONE FOLLOW — cone slightly follows scroll =====================
(function lightConeParallax() {
  const halo = document.getElementById('light-halo');
  const cone = document.getElementById('light-cone');
  if (!halo && !cone) return;

  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        const y = window.scrollY;
        const shift = y * 0.02;
        if (halo) halo.style.transform = `translateX(calc(-50% - ${shift}px)) translateZ(0)`;
        if (cone) cone.style.transform = `translateX(calc(-50% - ${shift}px)) translateZ(0)`;
        ticking = false;
      });
      ticking = true;
    }
  }, { passive: true });
})();
